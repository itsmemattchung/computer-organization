# t0
# to_uppercase
# This function accepts a pointer (to a string) and converts all lowercase letters
# to uppercase, directly manipulating the array -- in place. We do this to avoid:
#  1) managing a heap
#  2) passing in two arguments, forcing the caller to manage a runtime stack for the new string

	.data
user_string_1: .space 64
user_string_2: .space 64
adt_string_1: .space 4
adt_string_2: .space 4

str_prompt_1:	.asciiz	"\nInput first string:"
str_prompt_2:	.asciiz	"\nInput second string:"
str_prompt_3:	.asciiz "\nExiting!"
str_chars_in_bitmap_1:	.asciiz "First bit-map contains the following characters: "
str_chars_in_bitmap_2:	.asciiz "Second bit-map contains the following characters: "

	.text
	.globl main
main:
	li 	$v0, 4
	la 	$a0, str_prompt_1
	syscall
	li 	$v0, 8			# Prompt for string sys call
	la	$a0, user_string_1	# Load user_string_1 into argument
	li	$a1, 64
	syscall
	li 	$v0, 4
	la 	$a0, str_prompt_2
	syscall
	li 	$v0, 8			# Prompt for string sys call
	la	$a0, user_string_2	# Load user_string_1 into argument
	li	$a1, 64			 
	syscall
	la	$a0, user_string_1
	jal	to_uppercase
	la	$a0, user_string_1
	la	$a1, adt_string_1
	jal	adt_set
	li	$v0, 4
	la	$a0, str_chars_in_bitmap_1
	syscall
	la	$a0, adt_string_1		# Load bitstring into $a0, the first argument
	jal	print_letters_in_bit_string	# Call print_letters_in_bit_string

	li	$v0, 4
	la	$a0, str_chars_in_bitmap_2
	syscall
adt_bitstring_2:
	la	$a0, user_string_2
	jal	to_uppercase
	la	$a0, user_string_2
	la	$a1, adt_string_2
	jal	adt_set

	la	$a0, adt_string_2		# Load bitstring into $a0, the first argument
	jal	print_letters_in_bit_string	# Call print_letters_in_bit_string

	li 	$v0, 4				# Load print system call
	la 	$a0, str_prompt_3		# Print "exit"
	syscall
	li $v0, 10			# Load exit() system call
	syscall				# Exit to the program


adt_set:
	move	$t0, $a0
	move	$t6, $a1					# Load the address of the 32-bit string into $t6
	lw	$t1, 0($t6)					# Load word (32-bit) into $t1
	li	$t2, 0						# Initialize i (i.e. index) to 0

adt_set_while_not_end_of_string:
	add	$t3, $t2, $t0					# Calculate address
	lb	$t4, 0($t3)					# Load byte (not word) into $t4
	beq	$t4, 0, adt_set_end_while_not_end_of_string	# If null terminator (i.e. 0), then jump to end of while loop

adt_set_if_alphabetical_char:
	blt 	$t4, 65, adt_set_end_if_aphabetical_char	# Check if char less than 'A'
	bgt 	$t4, 90, adt_set_end_if_aphabetical_char	# Check if char is greater than 'Z'
	sub	$t4, $t4, 65					# Subtract ascii character by 65 - this is the amount we are going to shift left by
	li	$t5, 1						# $t5 used for bit masking
	sllv	$t5, $t5, $t4					# Position the letter into the correct position, determined by $t4
	or	$t1, $t1, $t5					# Or the adt set against the newly positioned character

adt_set_end_if_aphabetical_char:
	add $t0, $t0, 1
	j adt_set_while_not_end_of_string

adt_set_end_while_not_end_of_string:
	sw	$t1, 0($t6)					# Store 32-bit bit map into $t6
	jr $ra

to_uppercase:
	move	$t0, $a0				# Save array address from $a0 to $1
	li	$t1, 0					# Initialize i (i.e. index) to 0
while_not_end_of_string:
	add	$t2, $t1, $t0				# Calculate address
	lb	$t3, 0($t2)				# Load byte (not word) into $t2
	beq	$t3, 0, end_while_not_end_of_string	# If null terminator (i.e. 0), then jump to end of while loop

if_alphabetical_char:
	blt $t3, 97, end_if_aphabetical_char		# Check if char less than 'a'
	bgt $t3, 122, end_if_aphabetical_char		# Check if char is greater than 'z'

uppercase_char:
	andi	$t4, $t3, 0xDF				# Convert character to uppercase, regardless
	sb	$t4, 0($t2)				# Store byte into original position

end_if_aphabetical_char:
	add $t1, $t1, 1
	j while_not_end_of_string
end_while_not_end_of_string:
	jr $ra

print_letters_in_bit_string:
	add	$sp, $sp, -36				# Store the ret and allocate 32 bytes for ascii string
	sw	$ra, 0($sp)				# Store retunr address on the stack
	move	$t6, $sp				# Copy address of $rsp to $t6, the register holding address of ascii string
	add	$t6, $t6, 4				# Load address of the ascii string that we'll allocate for the print call
	lw	$t0, 0($a0)				# Load contents of bit-map (in $a0) into $t0
	li	$t1, 0					# Counter for bit string
	li	$t2, 0					# Counter to hold the offset for the new ascii string

while_not_end_of_bitstring:
	beq	$t1, 25, end_while_not_end_of_bitstring # Once we reach last character, break out of while loop
	srlv	$t3, $t0, $t1				# Shift right by counter
	and	$t3, $t3, 0x01				# and the newly shifted bitstring by 1

if_char_is_set:
	beq	$t3, 0, end_if_char_is_set
	add	$t4, $t1, 65				# Add 65 (i.e. first position for 'A') to $t1
	add	$t5, $t2, $t6				# Calculate address for char position in ascii string
	sb	$t4, 0($t5)				# Store ascii character into new ascii string
	add	$t2, $t2, 1				# Bump ascii string offset counter by 1

end_if_char_is_set:
	add $t1, $t1, 1					# Increment bit-string counter by 1
	j while_not_end_of_bitstring

end_while_not_end_of_bitstring:
	li	$t7, 0x0A				# Store new line
	sb	$t7, 1($t5)				# Store newline in penutlimate position
	li	$t7, 0					# Load null terminator (i.e. 0)
	sb	$t7, 2($t5)				# Store null terminator in last position
	lw	$ra, 0($sp)				# restore the return
	add	$sp, $sp, 36
	li 	$v0, 4					# Load print system call
	move	$a0, $t6				# Copy string into $a0
	syscall
	jr	$ra
